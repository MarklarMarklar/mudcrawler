import pygame
import random
import os
import math
import glob
from config import *
from enemy import Enemy, Boss
from asset_manager import get_asset_manager

class BloodPuddle:
    """Blood puddle that appears when monsters die"""
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.size = TILE_SIZE
        self.rect = pygame.Rect(x - self.size//2, y - self.size//2, self.size, self.size)
        self.asset_manager = get_asset_manager()
        self.texture = None
        
        # Try to load a random blood puddle texture
        try:
            blood_dir = os.path.join(TILE_SPRITES_PATH, "blood")
            if os.path.exists(blood_dir):
                blood_files = glob.glob(os.path.join(blood_dir, "*.png"))
                if blood_files:
                    selected_blood = random.choice(blood_files)
                    self.texture = self.asset_manager.load_image(selected_blood, scale=(self.size, self.size))
                    print(f"Selected blood puddle: {os.path.basename(selected_blood)}")
        except Exception as e:
            print(f"Failed to load blood puddle texture: {e}")
            self.texture = None
    
    def draw(self, surface):
        """Draw the blood puddle to the surface"""
        if self.texture:
            surface.blit(self.texture, self.rect)

class ArrowPickup:
    """Arrow pickup item that gives the player additional arrows"""
    def __init__(self, x, y):
        self.x = x
        self.y = y
        # Create a simple arrow shape
        self.size = TILE_SIZE // 2
        self.rect = pygame.Rect(x - self.size//2, y - self.size//2, self.size, self.size)
        self.arrow_amount = 2  # Each pickup gives 2 arrows
        self.collected = False
        self.pulse_timer = 0
        self.asset_manager = get_asset_manager()
        
        # Try to load arrow texture
        try:
            arrow_path = os.path.join(WEAPON_SPRITES_PATH, "rock.png")
            if os.path.exists(arrow_path):
                self.arrow_texture = self.asset_manager.load_image(arrow_path, scale=(self.size, self.size))
            else:
                self.arrow_texture = None
        except Exception as e:
            print(f"Failed to load arrow texture: {e}")
            self.arrow_texture = None
        
    def update(self):
        # Simple animation effect
        self.pulse_timer += 0.1
        
    def draw(self, surface):
        if self.collected:
            return
            
        try:
            # Pulsing effect
            pulse = math.sin(self.pulse_timer) * 0.2 + 0.8
            size = int(self.size * pulse)
            
            # Draw arrow pickup
            if self.arrow_texture:
                # Scale the texture based on pulse
                scaled_texture = pygame.transform.scale(self.arrow_texture, (size, size))
                # Draw centered at pickup position
                rect = scaled_texture.get_rect(center=(self.x, self.y))
                surface.blit(scaled_texture, rect)
            else:
                # Draw a fallback arrow shape if texture isn't available
                pygame.draw.circle(surface, BLUE, (self.x, self.y), size // 2)
                pygame.draw.polygon(surface, WHITE, [
                    (self.x, self.y - size // 2),
                    (self.x - size // 4, self.y + size // 4),
                    (self.x + size // 4, self.y + size // 4)
                ])
                
            # Add a glow effect
            glow_surf = pygame.Surface((size * 3, size * 3), pygame.SRCALPHA)
            pygame.draw.circle(glow_surf, (*BLUE[:3], 70), (size * 1.5, size * 1.5), size * pulse)
            glow_rect = glow_surf.get_rect(center=(self.x, self.y))
            surface.blit(glow_surf, glow_rect)
        except Exception as e:
            print(f"Error rendering arrow pickup: {e}")

class HealthPickup:
    """Health pickup item that restores player health"""
    def __init__(self, x, y):
        self.x = x
        self.y = y
        # Create a simple heart shape
        self.size = TILE_SIZE // 2
        self.rect = pygame.Rect(x - self.size//2, y - self.size//2, self.size, self.size)
        self.heal_amount = 20  # Flat 20 HP instead of percentage-based healing
        self.collected = False
        self.pulse_timer = 0
        self.asset_manager = get_asset_manager()
        
        # Try to load health pickup texture
        try:
            health_path = os.path.join(WEAPON_SPRITES_PATH, "health_pickup.png")
            if os.path.exists(health_path):
                self.health_texture = self.asset_manager.load_image(health_path, scale=(self.size, self.size))
            else:
                self.health_texture = None
        except Exception as e:
            print(f"Failed to load health pickup texture: {e}")
            self.health_texture = None
        
    def update(self):
        # Simple animation effect
        self.pulse_timer += 0.1
        
    def draw(self, surface):
        if self.collected:
            return
            
        try:
            # Pulsing effect
            pulse = math.sin(self.pulse_timer) * 0.2 + 0.8
            size = int(self.size * pulse)
            
            # Create a surface for the heart shape
            heart_surf = pygame.Surface((size, size), pygame.SRCALPHA)
            
            # Draw a red heart shape
            heart_color = (255, 0, 0, 200)  # Semi-transparent red
            
            # Draw heart using 2 circles and a triangle
            radius = size // 4
            x_offset = size // 4
            pygame.draw.circle(heart_surf, heart_color, (x_offset, radius), radius)  # Left circle
            pygame.draw.circle(heart_surf, heart_color, (size - x_offset, radius), radius)  # Right circle
            
            # Triangle for bottom of heart
            pygame.draw.polygon(heart_surf, heart_color, [
                (0, radius),
                (size // 2, size),
                (size, radius)
            ])
            
            # Add a glow effect
            glow_surf = pygame.Surface((size * 3, size * 3), pygame.SRCALPHA)
            glow_color = (255, 100, 100, 100)
            pygame.draw.circle(glow_surf, glow_color, (size * 1.5, size * 1.5), size * pulse)
            
            # Blit heart and glow to main surface
            heart_rect = heart_surf.get_rect(center=(self.x, self.y))
            glow_rect = glow_surf.get_rect(center=(self.x, self.y))
            
            surface.blit(glow_surf, glow_rect)
            surface.blit(heart_surf, heart_rect)
        except Exception as e:
            print(f"Error rendering health pickup: {e}")

class FireSwordPickup:
    """Special pickup item that gives the player a fire sword"""
    def __init__(self, x, y):
        self.x = x
        self.y = y
        # Make the pickup slightly larger for better visibility
        self.size = TILE_SIZE * 0.75
        self.rect = pygame.Rect(x - self.size//2, y - self.size//2, self.size, self.size)
        self.collected = False
        self.pulse_timer = 0
        self.asset_manager = get_asset_manager()
        
        # Load fire sword texture for the pickup
        try:
            sword_path = os.path.join(WEAPON_SPRITES_PATH, "fire_sword.png")
            if os.path.exists(sword_path):
                self.sword_texture = self.asset_manager.load_image(sword_path, scale=(self.size, self.size))
                print(f"Loaded fire sword pickup texture from {sword_path}")
            else:
                print(f"Fire sword texture not found at {sword_path}")
                self.sword_texture = None
        except Exception as e:
            print(f"Failed to load fire sword texture: {e}")
            self.sword_texture = None
        
        # Create a treasure chest that will "contain" the sword
        self.chest_size = TILE_SIZE * 1.5  # 50% larger than normal
        self.chest_rect = pygame.Rect(
            x - self.chest_size//2, 
            y - self.chest_size//2, 
            self.chest_size, 
            self.chest_size
        )
        self.chest_visible = True
        
        # Load a random treasure chest texture
        try:
            chest_dir = os.path.join(TILE_SPRITES_PATH, "destroyable walls")
            if os.path.exists(chest_dir):
                # Look for treasure chest textures
                chest_files = glob.glob(os.path.join(chest_dir, "treasure_*.png"))
                if chest_files:
                    selected_chest = random.choice(chest_files)
                    self.chest_texture = self.asset_manager.load_image(
                        selected_chest, 
                        scale=(self.chest_size, self.chest_size)
                    )
                    print(f"Selected chest texture: {os.path.basename(selected_chest)}")
                else:
                    print("No treasure chest textures found")
                    self.chest_texture = None
        except Exception as e:
            print(f"Failed to load chest texture: {e}")
            self.chest_texture = None
    
    def update(self):
        # Simple animation effect for the sword
        self.pulse_timer += 0.1
        
    def destroy_chest(self):
        """Called when player attacks the chest to reveal the sword"""
        if self.chest_visible:
            self.chest_visible = False
            print("Treasure chest destroyed, revealing fire sword!")
            return True
        return False
        
    def draw(self, surface):
        if self.collected:
            return
            
        try:
            # First check if we need to draw the chest
            if self.chest_visible:
                if self.chest_texture:
                    # Draw the chest
                    surface.blit(self.chest_texture, self.chest_rect)
                else:
                    # Fallback if no texture: draw a brown rectangle
                    pygame.draw.rect(surface, (139, 69, 19), self.chest_rect)
                    # Draw gold lock
                    lock_rect = pygame.Rect(
                        self.chest_rect.centerx - self.chest_rect.width//6,
                        self.chest_rect.centery - self.chest_rect.height//6,
                        self.chest_rect.width//3,
                        self.chest_rect.height//3
                    )
                    pygame.draw.rect(surface, (255, 215, 0), lock_rect)
                
                # We don't draw the sword when the chest is visible
                return
                
            # If chest is not visible, draw the sword with effects
            
            # Pulsing effect for the sword
            pulse = math.sin(self.pulse_timer) * 0.2 + 0.8
            size = int(self.size * pulse)
            
            if self.sword_texture:
                # Scale the texture based on pulse
                scaled_texture = pygame.transform.scale(self.sword_texture, (size, size))
                # Draw centered at pickup position
                rect = scaled_texture.get_rect(center=(self.x, self.y))
                surface.blit(scaled_texture, rect)
                
                # Add a fire glow effect
                glow_surf = pygame.Surface((size * 4, size * 4), pygame.SRCALPHA)
                
                # Orange-red glow
                glow_color = (255, 100, 20, 100)
                pygame.draw.circle(glow_surf, glow_color, (size * 2, size * 2), size * 2 * pulse)
                
                # Add a brighter center
                inner_color = (255, 200, 50, 150)
                pygame.draw.circle(glow_surf, inner_color, (size * 2, size * 2), size * pulse)
                
                glow_rect = glow_surf.get_rect(center=(self.x, self.y))
                surface.blit(glow_surf, glow_rect)
            else:
                # Fallback rendering if texture isn't available
                # Draw a glowing sword shape
                sword_surf = pygame.Surface((size, size), pygame.SRCALPHA)
                
                # Draw sword body
                pygame.draw.rect(sword_surf, (200, 150, 50), (size//2-2, size//4, 4, size//2))
                
                # Draw sword hilt
                pygame.draw.rect(sword_surf, (150, 100, 50), (size//2-6, size//4+size//2, 12, 8))
                
                # Add fire effect at the tip
                pygame.draw.polygon(sword_surf, (255, 100, 50), [
                    (size//2-4, size//4),
                    (size//2, size//8),
                    (size//2+4, size//4)
                ])
                
                # Add a glow effect
                glow_surf = pygame.Surface((size * 3, size * 3), pygame.SRCALPHA)
                pygame.draw.circle(glow_surf, (255, 100, 20, 100), (size * 1.5, size * 1.5), size * pulse)
                
                # Blit sword and glow
                sword_rect = sword_surf.get_rect(center=(self.x, self.y))
                glow_rect = glow_surf.get_rect(center=(self.x, self.y))
                
                surface.blit(glow_surf, glow_rect)
                surface.blit(sword_surf, sword_rect)
                
        except Exception as e:
            print(f"Error rendering fire sword pickup: {e}")

class Room:
    """Represents a single room in a dungeon level"""
    def __init__(self, x, y, level_number, room_type='normal'):
        # Position in the level grid (not pixels)
        self.grid_x = x
        self.grid_y = y
        
        # Room properties
        self.level_number = level_number
        self.room_type = room_type  # 'normal', 'start', 'boss', 'treasure'
        self.width = ROOM_WIDTH
        self.height = ROOM_HEIGHT
        self.tiles = []
        self.destroyable_walls = []  # Track destroyable walls
        
        # Doors - each can be True (open) or False (closed/no door)
        self.doors = {
            'north': False,
            'east': False,
            'south': False,
            'west': False
        }
        
        # Enemy spawning
        self.enemies = pygame.sprite.Group()
        self.boss = None
        self.cleared = False  # Room is cleared when all enemies are defeated
        
        # Level exit
        self.has_exit = False
        self.exit_position = None
        
        # Key drop
        self.key_dropped = False
        self.key_position = None
        self.key_picked_up = False  # New flag to track if key was already picked up
        
        # Health pickups
        self.health_pickups = []
        self.arrow_pickups = []
        
        # Fire sword pickup (for level 2 boss room)
        self.fire_sword_pickup = None
        self.fire_sword_dropped = False
        
        # Blood puddles
        self.blood_puddles = []
        
        # Generate room layout
        self.generate_room()
        
    def generate_room(self):
        """Generate the room layout based on room type"""
        # Create basic room layout - all walls
        self.tiles = [[1 for x in range(self.width)] for y in range(self.height)]
        self.destroyable_walls = [[False for x in range(self.width)] for y in range(self.height)]
        
        # Room center for symmetry
        center_x, center_y = self.width // 2, self.height // 2
        
        # Create open area
        for y in range(1, self.height - 1):
            for x in range(1, self.width - 1):
                # Edges of the room are always floor
                if (x == 1 or x == self.width - 2 or y == 1 or y == self.height - 2):
                    self.tiles[y][x] = 0
                else:
                    # Default to floor
                    self.tiles[y][x] = 0
        
        # Apply symmetric wall patterns based on room type
        if self.room_type == 'normal':
            # Pick a symmetric pattern for the room based on grid coordinates
            # Use both coordinates to create more variety
            pattern_seed = (abs(self.grid_x) * 3 + abs(self.grid_y) * 7) % 9
            
            if pattern_seed == 0:
                # Cross pattern with openings
                for y in range(2, self.height - 2):
                    for x in range(2, self.width - 2):
                        # Create a cross pattern in the middle
                        if (x == center_x or y == center_y) and not (
                            # Leave openings at the cardinal directions for passage
                            (x == center_x and (abs(y - center_y) < 3)) or
                            (y == center_y and (abs(x - center_x) < 3))
                        ):
                            self.tiles[y][x] = 1
                    
                        # Add some additional symmetric walls for density
                        elif (x == center_x - 4 or x == center_x + 4) and (5 < y < self.height - 6):
                            self.tiles[y][x] = 1
                        elif (y == center_y - 4 or y == center_y + 4) and (5 < x < self.width - 6):
                            self.tiles[y][x] = 1
                
            elif pattern_seed == 1:
                # Four symmetric corner rooms with central chamber
                # Define the corner rooms
                room_width = (self.width - 6) // 2
                room_height = (self.height - 6) // 2
                
                # Create walls to separate rooms
                for x in range(2, self.width - 2):
                    if abs(x - center_x) > 2:  # Leave opening in center
                        self.tiles[center_y][x] = 1  # Horizontal wall
                
                for y in range(2, self.height - 2):
                    if abs(y - center_y) > 2:  # Leave opening in center
                        self.tiles[y][center_x] = 1  # Vertical wall
                
                # Add some decorative walls in corner rooms (reflective symmetry)
                for corner_offset_y in [-1, 1]:
                    for corner_offset_x in [-1, 1]:
                        offset_y = center_y + corner_offset_y * (room_height // 2 + 2)
                        offset_x = center_x + corner_offset_x * (room_width // 2 + 2)
                        
                        # Add a 3x3 pattern in each corner room
                        for y_rel in range(-1, 2):
                            for x_rel in range(-1, 2):
                                # Skip center to allow passage
                                if not (x_rel == 0 and y_rel == 0):
                                    self.tiles[offset_y + y_rel][offset_x + x_rel] = 1
                
            elif pattern_seed == 2:
                # Diamond pattern
                # Make diamond pattern with clear center
                diamond_radius = min(center_x, center_y) - 3
                for y in range(2, self.height - 2):
                    for x in range(2, self.width - 2):
                        # Manhattan distance for diamond shape
                        distance = abs(x - center_x) + abs(y - center_y)
                        # Create diamond outline
                        if distance == diamond_radius:
                            self.tiles[y][x] = 1
                        # Add smaller inner diamond for more walls
                        elif distance == diamond_radius // 2 and diamond_radius > 6:
                            self.tiles[y][x] = 1
                
            elif pattern_seed == 3:
                # Pillar pattern with symmetrical pillars
                pillar_offsets = [
                    (center_x // 2, center_y // 2),
                    (center_x + center_x // 2, center_y // 2),
                    (center_x // 2, center_y + center_y // 2),
                    (center_x + center_x // 2, center_y + center_y // 2)
                ]
                
                # Add pillars
                for px, py in pillar_offsets:
                    self.tiles[py][px] = 1
                    self.tiles[py+1][px] = 1
                    self.tiles[py][px+1] = 1
                    self.tiles[py+1][px+1] = 1
                    
                # Add centered walls between pillars
                if center_x > 5 and center_y > 5:
                    # Horizontal connecting walls
                    for x in range(pillar_offsets[0][0] + 2, pillar_offsets[1][0]):
                        if (x - pillar_offsets[0][0]) % 3 != 0:  # Leave gaps for passage
                            self.tiles[pillar_offsets[0][1]][x] = 1
                            self.tiles[pillar_offsets[2][1]][x] = 1
                    
                    # Vertical connecting walls
                    for y in range(pillar_offsets[0][1] + 2, pillar_offsets[2][1]):
                        if (y - pillar_offsets[0][1]) % 3 != 0:  # Leave gaps for passage
                            self.tiles[y][pillar_offsets[0][0]] = 1
                            self.tiles[y][pillar_offsets[1][0]] = 1
                
            elif pattern_seed == 4:
                # Maze-like symmetric pattern
                for offset_y in range(3, center_y, 3):
                    # Horizontal walls with gaps
                    for x in range(3, self.width - 3):
                        # Skip position if it would block a passage
                        if (x - 3) % 6 != 0:
                            # Apply to both sides symmetrically
                            self.tiles[center_y - offset_y][x] = 1
                            self.tiles[center_y + offset_y][x] = 1
                
                for offset_x in range(3, center_x, 3):
                    # Vertical walls with gaps
                    for y in range(3, self.height - 3):
                        # Skip position if it would block a passage
                        if (y - 3) % 6 != 0:
                            # Apply to both sides symmetrically
                            self.tiles[y][center_x - offset_x] = 1
                            self.tiles[y][center_x + offset_x] = 1
            
            elif pattern_seed == 5:
                # Concentric circles pattern
                for y in range(2, self.height - 2):
                    for x in range(2, self.width - 2):
                        # Euclidean distance for circle shape
                        distance = math.sqrt((x - center_x)**2 + (y - center_y)**2)
                        # Create walls at specific radii
                        if int(distance) % 5 == 0 and distance > 3:
                            self.tiles[y][x] = 1
            
            elif pattern_seed == 6:
                # Checkerboard pattern with symmetric larger squares
                square_size = 3
                for y in range(3, self.height - 3, square_size):
                    for x in range(3, self.width - 3, square_size):
                        # Create symmetric pattern relative to center
                        if ((x // square_size) + (y // square_size)) % 2 == 0:
                            # Create a square of walls
                            for dy in range(square_size - 1):
                                for dx in range(square_size - 1):
                                    if 0 <= y + dy < self.height and 0 <= x + dx < self.width:
                                        self.tiles[y + dy][x + dx] = 1
            
            elif pattern_seed == 7:
                # Spiral pattern
                max_radius = min(center_x, center_y) - 3
                angles = [0, 90, 180, 270]  # Four arms for symmetry
                
                for radius in range(3, max_radius, 2):
                    for angle in angles:
                        # Convert polar coordinates to cartesian
                        rad_angle = math.radians(angle)
                        x = int(center_x + radius * math.cos(rad_angle))
                        y = int(center_y + radius * math.sin(rad_angle))
                        
                        # Make sure we're in bounds
                        if (2 <= x < self.width - 2 and 2 <= y < self.height - 2):
                            # Create a 2x2 wall segment
                            self.tiles[y][x] = 1
                            if y+1 < self.height - 2:
                                self.tiles[y+1][x] = 1
                            if x+1 < self.width - 2:
                                self.tiles[y][x+1] = 1
                            if y+1 < self.height - 2 and x+1 < self.width - 2:
                                self.tiles[y+1][x+1] = 1
            
            else:  # pattern_seed == 8
                # Symmetric "rooms connected by hallways"
                # Create four symmetrically placed rooms
                room_positions = [
                    (center_x - center_x//2, center_y - center_y//2),
                    (center_x + center_x//2, center_y - center_y//2),
                    (center_x - center_x//2, center_y + center_y//2),
                    (center_x + center_x//2, center_y + center_y//2)
                ]
                
                room_size = 5
                
                # Create room boundaries
                for room_x, room_y in room_positions:
                    for y in range(room_y - room_size//2, room_y + room_size//2 + 1):
                        for x in range(room_x - room_size//2, room_x + room_size//2 + 1):
                            if (x == room_x - room_size//2 or x == room_x + room_size//2 or
                                y == room_y - room_size//2 or y == room_y + room_size//2):
                                if 0 <= y < self.height and 0 <= x < self.width:
                                    self.tiles[y][x] = 1
                
                # Connect rooms with hallways (leaving openings in room walls)
                # Horizontal hallways
                for x in range(room_positions[0][0] + room_size//2 + 1, room_positions[1][0] - room_size//2):
                    self.tiles[center_y - center_y//2 - 1][x] = 1
                    self.tiles[center_y - center_y//2 + 1][x] = 1
                    self.tiles[center_y + center_y//2 - 1][x] = 1
                    self.tiles[center_y + center_y//2 + 1][x] = 1
                
                # Vertical hallways
                for y in range(room_positions[0][1] + room_size//2 + 1, room_positions[2][1] - room_size//2):
                    self.tiles[y][center_x - center_x//2 - 1] = 1
                    self.tiles[y][center_x - center_x//2 + 1] = 1
                    self.tiles[y][center_x + center_x//2 - 1] = 1
                    self.tiles[y][center_x + center_x//2 + 1] = 1
        
        elif self.room_type == 'start':
            # Start room - make sure center area is clear
            for y in range(center_y - 2, center_y + 3):
                for x in range(center_x - 2, center_x + 3):
                    if 0 <= y < self.height and 0 <= x < self.width:
                        self.tiles[y][x] = 0
            
            # Add some symmetric decorative walls near edges
            for offset in range(3, min(center_x, center_y) - 2, 4):
                # Top and bottom walls
                for x_offset in range(-2, 3):
                    if x_offset != 0:  # Skip the center for passage
                        x = center_x + x_offset
                        self.tiles[center_y - offset][x] = 1
                        self.tiles[center_y + offset][x] = 1
                
                # Left and right walls
                for y_offset in range(-2, 3):
                    if y_offset != 0:  # Skip the center for passage
                        y = center_y + y_offset
                        self.tiles[y][center_x - offset] = 1
                        self.tiles[y][center_x + offset] = 1
        
        elif self.room_type == 'boss':
            # Boss room with symmetric design
            # Clear center area - make it larger to ensure boss has room to move
            clear_radius = 5
            for y in range(center_y - clear_radius, center_y + clear_radius + 1):
                for x in range(center_x - clear_radius, center_x + clear_radius + 1):
                    if 0 <= y < self.height and 0 <= x < self.width:
                        self.tiles[y][x] = 0  # Set to floor
            
            # Add symmetric pillars at the corners
            pillar_distance = clear_radius + 1
            pillar_positions = [
                (center_x - pillar_distance, center_y - pillar_distance),
                (center_x + pillar_distance, center_y - pillar_distance),
                (center_x - pillar_distance, center_y + pillar_distance),
                (center_x + pillar_distance, center_y + pillar_distance)
            ]
            
            for px, py in pillar_positions:
                if (0 < px < self.width - 1 and 0 < py < self.height - 1 and
                    px + 1 < self.width - 1 and py + 1 < self.height - 1):
                    # Create 2x2 pillar
                    self.tiles[py][px] = 1
                    self.tiles[py+1][px] = 1
                    self.tiles[py][px+1] = 1
                    self.tiles[py+1][px+1] = 1
            
            # Add some additional decorative walls along edges of the boss arena
            edge_distance = clear_radius + 2
            for offset in range(-edge_distance, edge_distance + 1, 4):
                # Only place at specific intervals (skip some positions)
                if offset != 0 and abs(offset) != edge_distance:
                    # Top and bottom edges
                    if 3 <= center_y + offset < self.height - 3:
                        self.tiles[center_y + offset][center_x - edge_distance] = 1
                        self.tiles[center_y + offset][center_x + edge_distance] = 1
                    
                    # Left and right edges
                    if 3 <= center_x + offset < self.width - 3:
                        self.tiles[center_y - edge_distance][center_x + offset] = 1
                        self.tiles[center_y + edge_distance][center_x + offset] = 1
        
        elif self.room_type == 'treasure':
            # Treasure room - symmetric layout
            # Clear most areas first
            for y in range(1, self.height - 1):
                for x in range(1, self.width - 1):
                    self.tiles[y][x] = 0
            
            # Add symmetric corner structures
            corner_positions = [
                (2, 2),                       # Top-left
                (2, self.height - 5),         # Bottom-left
                (self.width - 5, 2),          # Top-right
                (self.width - 5, self.height - 5)  # Bottom-right
            ]
            
            for corner_x, corner_y in corner_positions:
                # Create L-shaped corner structures
                for i in range(3):
                    # Horizontal walls
                    self.tiles[corner_y][corner_x + i] = 1
                    # Vertical walls
                    self.tiles[corner_y + i][corner_x] = 1
            
            # Add a symmetric central structure - like a small room with openings
            central_room_size = 5
            for y in range(center_y - central_room_size//2, center_y + central_room_size//2 + 1):
                for x in range(center_x - central_room_size//2, center_x + central_room_size//2 + 1):
                    # Only create walls at the edges of this central structure
                    if (x == center_x - central_room_size//2 or x == center_x + central_room_size//2 or
                        y == center_y - central_room_size//2 or y == center_y + central_room_size//2):
                        # But leave openings at the cardinal directions
                        if not ((x == center_x and (y == center_y - central_room_size//2 or y == center_y + central_room_size//2)) or
                                (y == center_y and (x == center_x - central_room_size//2 or x == center_x + central_room_size//2))):
                            self.tiles[y][x] = 1
                    
        # Add doors based on door configuration
        if self.doors['north']:
            # North door - middle of top wall
            door_x = self.width // 2
            self.tiles[0][door_x] = 2  # Door tile
            # Make sure there's a clear path from the door (2x2 area)
            for y in range(1, 4):  # 3 tiles deep
                for x in range(door_x - 1, door_x + 2):  # 3 tiles wide
                    if 0 <= y < self.height and 0 <= x < self.width:
                        self.tiles[y][x] = 0  # Floor tile
            
        if self.doors['south']:
            # South door - middle of bottom wall
            door_x = self.width // 2
            self.tiles[self.height - 1][door_x] = 2  # Door tile
            # Make sure there's a clear path from the door (2x2 area)
            for y in range(self.height - 4, self.height - 1):  # 3 tiles deep
                for x in range(door_x - 1, door_x + 2):  # 3 tiles wide
                    if 0 <= y < self.height and 0 <= x < self.width:
                        self.tiles[y][x] = 0  # Floor tile
            
        if self.doors['east']:
            # East door - middle of right wall
            door_y = self.height // 2
            self.tiles[door_y][self.width - 1] = 2  # Door tile
            # Make sure there's a clear path from the door (2x2 area)
            for y in range(door_y - 1, door_y + 2):  # 3 tiles high
                for x in range(self.width - 4, self.width - 1):  # 3 tiles deep
                    if 0 <= y < self.height and 0 <= x < self.width:
                        self.tiles[y][x] = 0  # Floor tile
            
        if self.doors['west']:
            # West door - middle of left wall
            door_y = self.height // 2
            self.tiles[door_y][0] = 2  # Door tile
            # Make sure there's a clear path from the door (2x2 area)
            for y in range(door_y - 1, door_y + 2):  # 3 tiles high
                for x in range(1, 4):  # 3 tiles deep
                    if 0 <= y < self.height and 0 <= x < self.width:
                        self.tiles[y][x] = 0  # Floor tile
            
        # ADD DESTROYABLE WALLS (TREASURE CHESTS) SEPARATELY
        self._place_destroyable_walls()
        
    def _place_destroyable_walls(self):
        """Place destroyable walls (treasure chests) in the room"""
        # Destroyable walls should be separate from normal walls
        # They represent actual treasure chests placed in the environment
        
        max_chests = 0
        
        if self.room_type == 'normal':
            # Normal rooms have few treasure chests
            max_chests = 2
        elif self.room_type == 'boss':
            # Boss rooms have a medium number of chests
            max_chests = 3
        elif self.room_type == 'treasure':
            # Treasure rooms have more chests
            max_chests = 4
        elif self.room_type == 'start':
            # Start rooms have very few chests
            max_chests = 1
        
        # Adjust based on level number (higher levels have slightly more chests)
        level_bonus = min(1, self.level_number // 4)  # Capped at 1 extra chest
        max_chests += level_bonus
        
        # Find valid floor positions for placing chests
        valid_positions = []
        for y in range(2, self.height - 2):
            for x in range(2, self.width - 2):
                # Only consider floor tiles that aren't near doors
                if self.tiles[y][x] == 0 and not self._is_near_door(x, y):
                    # Make sure the position doesn't block critical paths
                    if not self._blocks_path(x, y):
                        valid_positions.append((x, y))
        
        # If no valid positions, we can't place any chests
        if not valid_positions:
            return
        
        # Place chests based on room type
        chests_placed = 0
        
        if self.room_type == 'boss':
            # Place chests near the boss arena perimeter
            center_x, center_y = self.width // 2, self.height // 2
            arena_radius = 6  # Slightly larger than clear_radius from boss room generation
            
            # Filter positions that are at the perimeter of the boss arena
            perimeter_positions = [
                pos for pos in valid_positions 
                if abs(math.sqrt((pos[0] - center_x)**2 + (pos[1] - center_y)**2) - arena_radius) < 2
            ]
            
            # Try to place in symmetric positions
            if perimeter_positions:
                # Sort by angle from center for symmetric placement
                perimeter_positions.sort(key=lambda pos: math.atan2(pos[1] - center_y, pos[0] - center_x))
                
                # Take evenly spaced positions for symmetry
                if len(perimeter_positions) >= max_chests:
                    step = len(perimeter_positions) // max_chests
                    for i in range(0, min(max_chests, len(perimeter_positions)), 1):
                        index = (i * step) % len(perimeter_positions)
                        x, y = perimeter_positions[index]
                        self._place_chest(x, y)
                        chests_placed += 1
                else:
                    # Not enough positions for perfect symmetry, place what we can
                    for pos in perimeter_positions[:max_chests]:
                        x, y = pos
                        self._place_chest(x, y)
                        chests_placed += 1
        
        elif self.room_type == 'treasure':
            # For treasure rooms, place chests in strategic locations
            center_x, center_y = self.width // 2, self.height // 2
            
            # Potential chest locations in a treasure room
            # Try central area first (but not the exact center)
            central_positions = [
                pos for pos in valid_positions
                if 2 < abs(pos[0] - center_x) + abs(pos[1] - center_y) < 6
            ]
            
            # Place symmetrically in central area
            if central_positions and chests_placed < max_chests:
                # Try to get pairs of symmetric positions
                symmetric_pairs = []
                for i, pos1 in enumerate(central_positions):
                    for pos2 in central_positions[i+1:]:
                        # Check if points are symmetric about the center
                        if (abs((pos1[0] - center_x) + (pos2[0] - center_x)) < 2 and
                            abs((pos1[1] - center_y) + (pos2[1] - center_y)) < 2):
                            symmetric_pairs.append((pos1, pos2))
                
                # Place symmetric pairs first
                for pair in symmetric_pairs:
                    if chests_placed + 2 <= max_chests:
                        for pos in pair:
                            x, y = pos
                            self._place_chest(x, y)
                            chests_placed += 1
                    else:
                        break
            
            # If we still need more, place in corners
            if chests_placed < max_chests:
                corner_zones = [
                    # Top-left
                    [(x, y) for x, y in valid_positions if x < center_x - 4 and y < center_y - 4],
                    # Top-right
                    [(x, y) for x, y in valid_positions if x > center_x + 4 and y < center_y - 4],
                    # Bottom-left
                    [(x, y) for x, y in valid_positions if x < center_x - 4 and y > center_y + 4],
                    # Bottom-right
                    [(x, y) for x, y in valid_positions if x > center_x + 4 and y > center_y + 4]
                ]
                
                # Try to place one chest in each corner if possible
                for corner in corner_zones:
                    if corner and chests_placed < max_chests:
                        pos = random.choice(corner)
                        self._place_chest(pos[0], pos[1])
                        chests_placed += 1
        
        else:  # 'normal' and 'start' rooms
            # For normal and start rooms, place chests in interesting locations
            
            # Find positions along walls but not next to doors
            wall_adjacent_positions = [
                pos for pos in valid_positions
                if self._is_adjacent_to_wall(pos[0], pos[1]) and not self._is_near_door(pos[0], pos[1])
            ]
            
            # If we found good wall-adjacent positions, use those
            if wall_adjacent_positions and len(wall_adjacent_positions) >= max_chests:
                random.shuffle(wall_adjacent_positions)
                for i in range(max_chests):
                    x, y = wall_adjacent_positions[i]
                    self._place_chest(x, y)
                    chests_placed += 1
            else:
                # Otherwise fall back to any valid position
                random.shuffle(valid_positions)
                for i in range(min(max_chests, len(valid_positions))):
                    x, y = valid_positions[i]
                    self._place_chest(x, y)
                    chests_placed += 1
    
    def _place_chest(self, x, y):
        """Place a chest at the specified position"""
        # Convert the floor tile to a wall
        self.tiles[y][x] = 1
        # Mark it as destroyable
        self.destroyable_walls[y][x] = True
        
    def _is_adjacent_to_wall(self, x, y):
        """Check if a position is adjacent to a wall but not a door"""
        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            check_x, check_y = x + dx, y + dy
            if (0 <= check_y < self.height and 0 <= check_x < self.width and
                self.tiles[check_y][check_x] == 1):  # Wall tile
                return True
        return False
    
    def _blocks_path(self, x, y):
        """Check if placing a chest at this position would block an important path"""
        # Count floor tiles around this position
        floor_count = 0
        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]:
            check_x, check_y = x + dx, y + dy
            if (0 <= check_y < self.height and 0 <= check_x < self.width and
                self.tiles[check_y][check_x] == 0):  # Floor tile
                floor_count += 1
        
        # Check if this position is in a narrow corridor (has few adjacent floor tiles)
        # or if it's near the center of the room
        center_x, center_y = self.width // 2, self.height // 2
        near_center = abs(x - center_x) < 3 and abs(y - center_y) < 3
        
        # Blocking a path if it's in a narrow corridor (2-3 floor tiles around) 
        # or very near the center
        return (2 <= floor_count <= 3) or near_center
    
    def _is_near_door(self, x, y):
        """Check if a position is near a door"""
        # Check surrounding 5x5 area for door tiles
        for dy in range(-2, 3):
            for dx in range(-2, 3):
                check_x, check_y = x + dx, y + dy
                if (0 <= check_y < self.height and 0 <= check_x < self.width and
                    self.tiles[check_y][check_x] == 2):  # Door tile
                    return True
        return False
        
    def try_destroy_wall(self, x, y):
        """Try to destroy a wall at the given tile position"""
        # Check if position is within bounds
        if not (0 <= y < self.height and 0 <= x < self.width):
            print(f"Room: Wall position {x},{y} is out of bounds")
            return False
        
        # Add debug output
        print(f"Room: Checking wall at {x},{y}: tile={self.tiles[y][x]}, destroyable={self.destroyable_walls[y][x] if self.tiles[y][x] == 1 else 'N/A'}")
        
        # Check if there's a destroyable wall at this position
        if self.tiles[y][x] == 1 and self.destroyable_walls[y][x]:
            print(f"Room: Found destroyable wall at {x},{y}")
            # Destroy the wall
            self.tiles[y][x] = 0
            self.destroyable_walls[y][x] = False
            
            # Determine what kind of pickup to spawn
            pickup_roll = random.random()
            center_x = x * TILE_SIZE + TILE_SIZE // 2
            center_y = y * TILE_SIZE + TILE_SIZE // 2
            
            # 30% chance to spawn a health pickup
            if pickup_roll < 0.3:
                self.health_pickups.append(HealthPickup(center_x, center_y))
                print(f"Room: Health pickup spawned at {center_x}, {center_y} from destroyed wall")
            # 20% chance to spawn an arrow pickup
            elif pickup_roll < 0.5:
                self.arrow_pickups.append(ArrowPickup(center_x, center_y))
                print(f"Room: Arrow pickup spawned at {center_x}, {center_y} from destroyed wall")
            
            print(f"Room: Successfully destroyed wall at {x},{y}")
            return True
        else:
            print(f"Room: No destroyable wall at {x},{y}")
            # Only return true if we actually destroyed a wall
            return False
        
    def try_pickup_health(self, player_rect):
        """Check if player is picking up a health item"""
        for pickup in self.health_pickups:
            if not pickup.collected and pickup.rect.colliderect(player_rect):
                pickup.collected = True
                print(f"Player picked up health in room ({self.grid_x}, {self.grid_y})")
                return pickup.heal_amount
        return 0
        
    def try_pickup_arrows(self, player_rect):
        """Check if player is picking up arrows"""
        for pickup in self.arrow_pickups:
            if not pickup.collected and pickup.rect.colliderect(player_rect):
                pickup.collected = True
                print(f"Player picked up arrows in room ({self.grid_x}, {self.grid_y})")
                return pickup.arrow_amount
        return 0
        
    def try_pickup_fire_sword(self, player_rect):
        """Check if player is picking up the fire sword"""
        if self.fire_sword_pickup and not self.fire_sword_pickup.collected and not self.fire_sword_pickup.chest_visible:
            if self.fire_sword_pickup.rect.colliderect(player_rect):
                self.fire_sword_pickup.collected = True
                print(f"Player picked up fire sword in room ({self.grid_x}, {self.grid_y})")
                return True
        return False
        
    def try_destroy_fire_sword_chest(self, attack_rect):
        """Check if player is attacking the fire sword chest"""
        if self.fire_sword_pickup and self.fire_sword_pickup.chest_visible:
            if self.fire_sword_pickup.chest_rect.colliderect(attack_rect):
                return self.fire_sword_pickup.destroy_chest()
        return False
        
    def spawn_enemies(self, num_enemies, level_instance=None):
        """Spawn enemies in the room based on level number"""
        attempts = 0
        max_attempts = 100  # Prevent infinite loops
        
        for _ in range(num_enemies):
            spawned = False
            attempts = 0
            
            while not spawned and attempts < max_attempts:
                tile_x = random.randint(1, self.width - 2)
                tile_y = random.randint(1, self.height - 2)
                
                # Only spawn on floor tiles away from doors
                if self.tiles[tile_y][tile_x] == 0 and not self.near_door(tile_x, tile_y):
                    enemy = Enemy(tile_x * TILE_SIZE, tile_y * TILE_SIZE, None, self.level_number, level_instance)
                    self.enemies.add(enemy)
                    spawned = True
                
                attempts += 1
                    
    def spawn_boss(self, level_instance=None):
        """Spawn a boss in the room (for boss rooms only)"""
        if self.room_type != 'boss':
            return
            
        # Try to place boss in the center first
        center_x = (self.width // 2) * TILE_SIZE
        center_y = (self.height // 2) * TILE_SIZE
        
        # Check if center position is valid (not a wall)
        if self.is_valid_spawn_position(center_x, center_y):
            self.boss = Boss(center_x, center_y, self.level_number, level_instance)
            print(f"Boss spawned at center position ({center_x}, {center_y})")
            return
            
        # If center is not valid, search for a valid position
        print("Center position is not valid for boss. Searching for valid position...")
        
        # Search in expanding circles around the center
        for radius in range(1, min(self.width, self.height) // 2):
            # Try positions in a square around the center
            for offset_y in range(-radius, radius + 1):
                for offset_x in range(-radius, radius + 1):
                    # Skip positions not on the edge of the square
                    if abs(offset_x) != radius and abs(offset_y) != radius:
                        continue
                        
                    test_x = center_x + offset_x * TILE_SIZE
                    test_y = center_y + offset_y * TILE_SIZE
                    
                    if self.is_valid_spawn_position(test_x, test_y):
                        self.boss = Boss(test_x, test_y, self.level_number, level_instance)
                        print(f"Boss spawned at alternative position ({test_x}, {test_y})")
                        return
        
        # If we got here, we couldn't find a valid position
        # As a last resort, try every floor tile in the room
        for y in range(1, self.height - 1):
            for x in range(1, self.width - 1):
                if self.tiles[y][x] == 0:  # Floor tile
                    pixel_x = x * TILE_SIZE
                    pixel_y = y * TILE_SIZE
                    
                    if self.is_valid_spawn_position(pixel_x, pixel_y):
                        self.boss = Boss(pixel_x, pixel_y, self.level_number, level_instance)
                        print(f"Boss spawned at fallback position ({pixel_x}, {pixel_y})")
                        return
                        
        # If we still can't find a position, log an error
        print("ERROR: Could not find a valid position for boss spawn!")
        
    def near_door(self, tile_x, tile_y):
        """Check if a tile is near a door"""
        # Check for north door
        if self.doors['north'] and tile_y < 3 and abs(tile_x - self.width // 2) < 2:
            return True
            
        # Check for south door
        if self.doors['south'] and tile_y > self.height - 4 and abs(tile_x - self.width // 2) < 2:
            return True
            
        # Check for east door
        if self.doors['east'] and tile_x > self.width - 4 and abs(tile_y - self.height // 2) < 2:
            return True
            
        # Check for west door
        if self.doors['west'] and tile_x < 3 and abs(tile_y - self.height // 2) < 2:
            return True
            
        return False
        
    def is_valid_spawn_position(self, pixel_x, pixel_y):
        """Check if position is valid for spawning"""
        tile_x = pixel_x // TILE_SIZE
        tile_y = pixel_y // TILE_SIZE
        
        # Check if position is within bounds
        if tile_y < 0 or tile_y >= self.height or tile_x < 0 or tile_x >= self.width:
            return False
            
        # Check if position is a floor tile
        if self.tiles[tile_y][tile_x] != 0:
            return False
            
        # Check distance from enemies
        for enemy in self.enemies:
            dx = enemy.rect.x - pixel_x
            dy = enemy.rect.y - pixel_y
            if (dx * dx + dy * dy) < (TILE_SIZE * 3) * (TILE_SIZE * 3):
                return False
                
        return True
        
    def get_valid_player_position(self):
        """Find a valid position for the player to spawn in this room"""
        # For start room, use center
        if self.room_type == 'start':
            return (self.width // 2) * TILE_SIZE + TILE_SIZE // 2, (self.height // 2) * TILE_SIZE + TILE_SIZE // 2
            
        # For door transitions, place player just inside the appropriate door
        # This will be used when transitioning between rooms
        
        # For new rooms, find any valid floor tile
        for y in range(1, self.height - 1):
            for x in range(1, self.width - 1):
                if self.tiles[y][x] == 0:
                    # Return the center of the tile
                    return x * TILE_SIZE + TILE_SIZE // 2, y * TILE_SIZE + TILE_SIZE // 2
                    
        # Fallback - shouldn't happen
        return (self.width // 2) * TILE_SIZE, (self.height // 2) * TILE_SIZE
        
    def update(self, player):
        """Update entities in the room"""
        # Update enemies
        for enemy in self.enemies:
            enemy.update(player)
        
        # Update boss if present
        if self.boss and self.boss.health > 0:
            self.boss.update(player)
        elif self.boss and self.boss.health <= 0:
            # Create blood puddle at boss location
            if not hasattr(self, 'boss_blood_created') or not self.boss_blood_created:
                # Create a larger blood puddle for the boss (by adding multiple puddles)
                for _ in range(3):
                    offset_x = random.randint(-TILE_SIZE//2, TILE_SIZE//2)
                    offset_y = random.randint(-TILE_SIZE//2, TILE_SIZE//2)
                    self.blood_puddles.append(BloodPuddle(self.boss.rect.centerx + offset_x, self.boss.rect.centery + offset_y))
                self.boss_blood_created = True
                
            # Boss is defeated, drop the key
            self.drop_key()
            
            # For level 2 boss, drop the fire sword
            if self.level_number == 2 and not self.fire_sword_dropped:
                self.drop_fire_sword()
            
        # Check for enemy deaths
        for enemy in list(self.enemies):
            if enemy.health <= 0:
                pickup_roll = random.random()
                
                # 10% chance to drop a health pickup when enemy dies
                if pickup_roll < 0.1:
                    self.health_pickups.append(HealthPickup(enemy.rect.centerx, enemy.rect.centery))
                    print(f"Health pickup spawned from defeated enemy at {enemy.rect.centerx}, {enemy.rect.centery}")
                # 8% chance to drop an arrow pickup when enemy dies
                elif pickup_roll < 0.18:
                    self.arrow_pickups.append(ArrowPickup(enemy.rect.centerx, enemy.rect.centery))
                    print(f"Arrow pickup spawned from defeated enemy at {enemy.rect.centerx}, {enemy.rect.centery}")
                    
                # Create a blood puddle where the enemy died
                self.blood_puddles.append(BloodPuddle(enemy.rect.centerx, enemy.rect.centery))
                
                # Remove the enemy
                self.enemies.remove(enemy)
                
        # Update pickup animations
        for pickup in self.health_pickups:
            pickup.update()
            
        for pickup in self.arrow_pickups:
            pickup.update()
            
        # Update fire sword pickup if it exists
        if self.fire_sword_pickup:
            self.fire_sword_pickup.update()
            
        # Check if room is cleared (all enemies and boss defeated)
        if len(self.enemies) == 0 and (not self.boss or self.boss.health <= 0):
            self.cleared = True
            
    def check_collision(self, rect):
        """Check if a rectangle collides with walls in this room"""
        tile_x1 = max(0, rect.left // TILE_SIZE)
        tile_x2 = min(self.width - 1, rect.right // TILE_SIZE)
        tile_y1 = max(0, rect.top // TILE_SIZE)
        tile_y2 = min(self.height - 1, rect.bottom // TILE_SIZE)
        
        for y in range(tile_y1, tile_y2 + 1):
            for x in range(tile_x1, tile_x2 + 1):
                if 0 <= y < self.height and 0 <= x < self.width:
                    if self.tiles[y][x] == 1:  # Wall tile
                        wall_rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE,
                                              TILE_SIZE, TILE_SIZE)
                        if rect.colliderect(wall_rect):
                            return True
        return False
        
    def check_door_collision(self, rect):
        """Check if player is touching a door, return direction if yes"""
        tile_x1 = max(0, rect.left // TILE_SIZE)
        tile_x2 = min(self.width - 1, rect.right // TILE_SIZE)
        tile_y1 = max(0, rect.top // TILE_SIZE)
        tile_y2 = min(self.height - 1, rect.bottom // TILE_SIZE)
        
        for y in range(tile_y1, tile_y2 + 1):
            for x in range(tile_x1, tile_x2 + 1):
                if 0 <= y < self.height and 0 <= x < self.width:
                    if self.tiles[y][x] == 2:  # Door tile
                        door_rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE,
                                             TILE_SIZE, TILE_SIZE)
                        if rect.colliderect(door_rect):
                            # Determine which door was touched
                            if y == 0:
                                return 'north'
                            elif y == self.height - 1:
                                return 'south'
                            elif x == 0:
                                return 'west'
                            elif x == self.width - 1:
                                return 'east'
        return None

    def draw(self, surface, tiles, level=None):
        """Draw the room and all entities in it"""
        # Calculate grid dimensions and set up a surface for the room
        grid_width = self.width * TILE_SIZE
        grid_height = self.height * TILE_SIZE
        
        # Draw tiles first (bottom layer)
        self.draw_tiles(surface, tiles)
        
        # Draw room type indicator (debug)
        if DEBUG_MODE:
            debug_font = pygame.font.Font(None, 32)
            room_text = debug_font.render(f"Room: {self.room_type} ({self.grid_x}, {self.grid_y})", True, (255, 255, 255))
            surface.blit(room_text, (20, 20))
        
        # Draw exit door if this room has one
        if self.has_exit:
            x, y = self.exit_position
            pixel_x = x * TILE_SIZE
            pixel_y = y * TILE_SIZE
            
            # If we have the key, draw an open/glowing exit door
            if level and level.has_key:
                # Draw the open exit door
                if 'exit_open' in tiles:
                    surface.blit(tiles['exit_open'], (pixel_x, pixel_y))
                else:
                    # Fallback to using a colored rectangle
                    exit_rect = pygame.Rect(pixel_x, pixel_y, TILE_SIZE, TILE_SIZE)
                    pygame.draw.rect(surface, (0, 255, 0), exit_rect)
                
                # Draw glowing effects for the exit
                self.draw_exit_glow(surface, tiles, pixel_x, pixel_y)
            else:
                # Draw the closed exit door
                if 'exit' in tiles:
                    surface.blit(tiles['exit'], (pixel_x, pixel_y))
                else:
                    # Fallback to using a colored rectangle
                    exit_rect = pygame.Rect(pixel_x, pixel_y, TILE_SIZE, TILE_SIZE)
                    pygame.draw.rect(surface, (150, 150, 150), exit_rect)
        
        # Draw the dropped key if it exists and hasn't been picked up
        if self.key_dropped and not self.key_picked_up and self.key_position:
            # Make a pulsing effect for the key
            key_pulse = math.sin(pygame.time.get_ticks() / 200) * 0.2 + 0.8  # Subtle pulse
            
            if 'key' in tiles:
                # Calculate pulse size
                key_scale = int(TILE_SIZE * key_pulse)
                
                # Scale the key texture
                try:
                    key_image = pygame.transform.scale(tiles['key'], (key_scale, key_scale))
                except Exception as e:
                    # If scaling fails, use the original image
                    key_image = tiles['key']
                    print(f"Error scaling key: {e}")
                
                # Get the centered rect for the key
                key_rect = key_image.get_rect(center=self.key_position)
                
                # Draw the key
                surface.blit(key_image, key_rect)
                
                # Add a glow effect for better visibility
                try:
                    glow_radius = int(TILE_SIZE * 1.5 * key_pulse)
                    glow_surf = pygame.Surface((glow_radius * 2, glow_radius * 2), pygame.SRCALPHA)
                    glow_color = (255, 215, 0, 100)  # Semi-transparent gold
                    pygame.draw.circle(glow_surf, glow_color, (glow_radius, glow_radius), glow_radius)
                    glow_rect = glow_surf.get_rect(center=self.key_position)
                    surface.blit(glow_surf, glow_rect)
                except Exception as e:
                    print(f"Error drawing key glow: {e}")
            else:
                # Fallback - draw a simple yellow rectangle
                key_rect = pygame.Rect(self.key_position[0] - TILE_SIZE//4, 
                                      self.key_position[1] - TILE_SIZE//4,
                                      TILE_SIZE//2, TILE_SIZE//2)
                pygame.draw.rect(surface, (255, 255, 0), key_rect)
                
        # Draw blood puddles first (bottom layer)
        for puddle in self.blood_puddles:
            puddle.draw(surface)
            
        # Draw health pickups
        for pickup in self.health_pickups:
            if not pickup.collected:
                pickup.draw(surface)
                
        # Draw arrow pickups
        for pickup in self.arrow_pickups:
            if not pickup.collected:
                pickup.draw(surface)
                
        # Draw fire sword pickup if it exists
        if self.fire_sword_pickup and not self.fire_sword_pickup.collected:
            self.fire_sword_pickup.draw(surface)
                
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface)
            
        # Draw boss if it exists
        if self.boss and self.boss.health > 0:
            self.boss.draw(surface)
        
        # Draw exit confirmation if needed
        if self.show_exit_confirmation:
            self.draw_exit_confirmation(surface)
        
    def draw_exit_confirmation(self, surface):
        """Draw confirmation dialog when trying to exit level"""
        # This dialog should be drawn directly on the screen, not affected by camera zoom
        
        # Darken the screen
        overlay = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))  # Semi-transparent black
        surface.blit(overlay, (0, 0))
        
        # Create the dialog box with rounded corners
        dialog_width = 400
        dialog_height = 200
        dialog_x = (WINDOW_WIDTH - dialog_width) // 2
        dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
        
        dialog_rect = pygame.Rect(dialog_x, dialog_y, dialog_width, dialog_height)
        
        # Draw a rounded rectangle for the dialog
        dialog_surface = pygame.Surface((dialog_width, dialog_height), pygame.SRCALPHA)
        dialog_surface.fill((0, 0, 0, 0))  # Transparent
        
        # Dialog background color
        dialog_bg_color = (80, 50, 30, 230)  # Dark brown with transparency
        dialog_border_color = (255, 255, 0)  # Yellow border to match menu buttons
        
        # Draw dialog with rounded corners (similar to button style)
        pygame.draw.rect(dialog_surface, dialog_bg_color, pygame.Rect(0, 0, dialog_width, dialog_height), 0, 15)
        pygame.draw.rect(dialog_surface, dialog_border_color, pygame.Rect(0, 0, dialog_width, dialog_height), 3, 15)
        
        surface.blit(dialog_surface, dialog_rect)
        
        # Load the pixelated font
        font_path = os.path.join(ASSET_PATH, "fonts/PixelatedEleganceRegular-ovyAA.ttf")
        if os.path.exists(font_path):
            font = pygame.font.Font(font_path, 30)  # Reduced from 36 to 30
            small_font = pygame.font.Font(font_path, 28)  # Reduced from 30 to 28
        else:
            font = pygame.font.Font(None, 30)  # Reduced from 36 to 30
            small_font = pygame.font.Font(None, 28)  # Reduced from 30 to 28
        
        # Dialog text with pixelated font
        text = font.render("Exit to next level?", True, (255, 245, 225))
        text_rect = text.get_rect(center=(WINDOW_WIDTH // 2, dialog_y + 65))  # Adjusted from 60 to 65
        surface.blit(text, text_rect)
        
        # Buttons
        button_width = 120
        button_height = 50
        button_spacing = 40
        
        # Yes button with rounded corners
        yes_rect = pygame.Rect(
            dialog_x + (dialog_width // 2) - button_width - (button_spacing // 2),
            dialog_y + dialog_height - 70,
            button_width,
            button_height
        )
        
        # Create button surfaces with rounded corners
        yes_surface = pygame.Surface((button_width, button_height), pygame.SRCALPHA)
        yes_surface.fill((0, 0, 0, 0))  # Transparent
        
        # Button colors - matching menu buttons
        yes_color = (80, 50, 30, 230)  # Dark background
        yes_border = (255, 255, 0)     # Yellow border
        
        # Draw rounded rectangle for YES button
        pygame.draw.rect(yes_surface, yes_color, pygame.Rect(0, 0, button_width, button_height), 0, 10)
        pygame.draw.rect(yes_surface, yes_border, pygame.Rect(0, 0, button_width, button_height), 3, 10)
        
        surface.blit(yes_surface, yes_rect)
        
        # Text with slight shadow for better readability
        yes_text_shadow = small_font.render("YES", True, (0, 0, 0, 180))
        yes_text = small_font.render("YES", True, (255, 245, 225))  # Same color as menu buttons
        
        yes_text_rect = yes_text.get_rect(center=yes_rect.center)
        yes_shadow_rect = yes_text_rect.copy()
        yes_shadow_rect.x += 2
        yes_shadow_rect.y += 2
        
        surface.blit(yes_text_shadow, yes_shadow_rect)
        surface.blit(yes_text, yes_text_rect)
        
        # No button with rounded corners
        no_rect = pygame.Rect(
            dialog_x + (dialog_width // 2) + (button_spacing // 2),
            dialog_y + dialog_height - 70,
            button_width,
            button_height
        )
        
        # Create no button surface
        no_surface = pygame.Surface((button_width, button_height), pygame.SRCALPHA)
        no_surface.fill((0, 0, 0, 0))  # Transparent
        
        # Button colors
        no_color = (80, 50, 30, 230)  # Dark background
        no_border = (255, 255, 0)     # Yellow border
        
        # Draw rounded rectangle for NO button
        pygame.draw.rect(no_surface, no_color, pygame.Rect(0, 0, button_width, button_height), 0, 10)
        pygame.draw.rect(no_surface, no_border, pygame.Rect(0, 0, button_width, button_height), 3, 10)
        
        surface.blit(no_surface, no_rect)
        
        # Text with slight shadow
        no_text_shadow = small_font.render("NO", True, (0, 0, 0, 180))
        no_text = small_font.render("NO", True, (255, 245, 225))  # Same color as menu buttons
        
        no_text_rect = no_text.get_rect(center=no_rect.center)
        no_shadow_rect = no_text_rect.copy()
        no_shadow_rect.x += 2
        no_shadow_rect.y += 2
        
        surface.blit(no_text_shadow, no_shadow_rect)
        surface.blit(no_text, no_text_rect)
        
        # Return button rects for click handling
        return yes_rect, no_rect 

    def draw_tiles(self, surface, tiles):
        """Draw all the tiles in the room"""
        for y in range(self.height):
            for x in range(self.width):
                tile_x = x * TILE_SIZE
                tile_y = y * TILE_SIZE
                
                if self.tiles[y][x] == 1:  # Wall
                    if hasattr(self, 'destroyable_walls') and len(self.destroyable_walls) > y and len(self.destroyable_walls[y]) > x and self.destroyable_walls[y][x]:
                        # Draw destroyable wall texture
                        if 'destroyable_wall' in tiles:
                            surface.blit(tiles['destroyable_wall'], (tile_x, tile_y))
                        else:
                            # Fallback - draw a brown rectangle
                            wall_rect = pygame.Rect(tile_x, tile_y, TILE_SIZE, TILE_SIZE)
                            pygame.draw.rect(surface, (139, 69, 19), wall_rect)
                    else:
                        # Normal wall
                        if 'wall' in tiles:
                            surface.blit(tiles['wall'], (tile_x, tile_y))
                        else:
                            # Fallback - draw a gray rectangle
                            wall_rect = pygame.Rect(tile_x, tile_y, TILE_SIZE, TILE_SIZE)
                            pygame.draw.rect(surface, (100, 100, 100), wall_rect)
                elif self.tiles[y][x] == 2:  # Door
                    if 'door' in tiles:
                        surface.blit(tiles['door'], (tile_x, tile_y))
                    else:
                        # Fallback - draw a brown rectangle
                        door_rect = pygame.Rect(tile_x, tile_y, TILE_SIZE, TILE_SIZE)
                        pygame.draw.rect(surface, (150, 100, 50), door_rect)
                elif self.tiles[y][x] == EXIT_DOOR_TILE:  # Exit door - handled separately
                    pass  # We draw the exit door separately to handle glowing effects
                else:  # Floor
                    if 'floor' in tiles:
                        surface.blit(tiles['floor'], (tile_x, tile_y))
                    else:
                        # Fallback - draw a light gray rectangle
                        floor_rect = pygame.Rect(tile_x, tile_y, TILE_SIZE, TILE_SIZE)
                        pygame.draw.rect(surface, (200, 200, 200), floor_rect)
    
    def draw_exit_glow(self, surface, tiles, tile_x, tile_y):
        """Draw the glowing effect around the exit door"""
        if 'exit_open_glow' in tiles:
            # Create pulsing effect using sine wave
            pulse = 0.5 + 0.5 * abs(math.sin(pygame.time.get_ticks() / 400))
            
            # Scale the glow based on pulse
            original_glow = tiles['exit_open_glow']
            glow_size = 1.2 + pulse * 0.3  # Varies between 1.2x and 1.5x
            
            try:
                glow_width = int(original_glow.get_width() * glow_size)
                glow_height = int(original_glow.get_height() * glow_size)
                glow_surface = pygame.transform.scale(original_glow, (glow_width, glow_height))
                
                # Set alpha based on pulse
                alpha = int(150 + 105 * pulse)  # Varies between 150 and 255
                glow_surface.set_alpha(alpha)
                
                # Center the glow on the exit door
                glow_x = tile_x + TILE_SIZE // 2 - glow_surface.get_width() // 2
                glow_y = tile_y + TILE_SIZE // 2 - glow_surface.get_height() // 2
                
                # Draw the glow
                surface.blit(glow_surface, (glow_x, glow_y))
            except Exception as e:
                print(f"Error drawing exit glow: {e}")
        else:
            # Fallback - draw a simple glow effect
            glow_radius = int(TILE_SIZE * (1.5 + 0.5 * abs(math.sin(pygame.time.get_ticks() / 400))))
            glow_surf = pygame.Surface((glow_radius * 2, glow_radius * 2), pygame.SRCALPHA)
            glow_color = (255, 255, 0, 100)  # Semi-transparent yellow
            pygame.draw.circle(glow_surf, glow_color, (glow_radius, glow_radius), glow_radius)
            glow_rect = glow_surf.get_rect(center=(tile_x + TILE_SIZE // 2, tile_y + TILE_SIZE // 2))
            surface.blit(glow_surf, glow_rect) 

    def check_arrow_pickup(self, player_rect):
        """Check if player is picking up arrows"""
        try:
            current_room = self.rooms[self.current_room_coords]
            return current_room.try_pickup_arrows(player_rect)
        except Exception as e:
            print(f"Error in check_arrow_pickup: {e}")
            return 0
            
    def check_fire_sword_pickup(self, player_rect):
        """Check if player is picking up the fire sword"""
        try:
            current_room = self.rooms[self.current_room_coords]
            return current_room.try_pickup_fire_sword(player_rect)
        except Exception as e:
            print(f"Error in check_fire_sword_pickup: {e}")
            return False
            
    def check_fire_sword_chest_destruction(self, attack_rect):
        """Check if player's attack is destroying the fire sword chest"""
        try:
            current_room = self.rooms[self.current_room_coords]
            return current_room.try_destroy_fire_sword_chest(attack_rect)
        except Exception as e:
            print(f"Error in check_fire_sword_chest_destruction: {e}")
            return False
            
    def draw(self, surface):
        """Draw only the current room"""
        try:
            current_room = self.rooms[self.current_room_coords]
            current_room.draw(surface, self.tiles, self)
        except Exception as e:
            print(f"Error in Level.draw: {e}")

class Level:
    """Represents an entire dungeon level composed of multiple rooms"""
    def __init__(self, level_number, asset_manager):
        self.level_number = level_number
        self.asset_manager = asset_manager
        
        # Selected textures for this level
        self.selected_floor = None
        self.selected_wall = None
        self.selected_door = None
        self.selected_enemy_textures = {}
        
        # For compatibility with enemy.py - add individual texture selectors
        self.selected_slime_texture = None
        self.selected_skeleton_texture = None
        self.selected_ghost_texture = None
        
        # Room and exit properties
        self.rooms = {}  # Dictionary of (x, y) -> Room
        self.current_room_coords = None
        self.start_room_coords = None
        self.exit_room_coords = None
        self.has_key = False  # Player needs to find a key to exit
        
        # Level completion flag
        self.completed = False
        
        # Confirmation dialog for exit
        self.show_exit_confirmation = False
        
        # Load textures
        self.tiles = {}
        self.load_tile_textures()
        
        # Generate the level
        self.generate_level()
        
    def get_all_destroyable_wall_textures(self):
        """Get all available destroyable wall textures"""
        try:
            # Check the destroyable walls directory for textures
            directory = os.path.join(TILE_SPRITES_PATH, "destroyable walls")
            if os.path.exists(directory):
                files = [f for f in os.listdir(directory) if f.endswith('.png')]
                return [os.path.join(directory, f) for f in files]
            else:
                print(f"Destroyable walls directory not found at {directory}")
                return []
        except Exception as e:
            print(f"Error getting destroyable wall textures: {e}")
            return []
    
    def get_random_destroyable_wall_texture(self):
        """Get a random destroyable wall texture"""
        textures = self.get_all_destroyable_wall_textures()
        if textures:
            return random.choice(textures)
        return None
    
    def get_random_enemy_texture(self, enemy_type):
        """Get a random texture for the specified enemy type"""
        try:
            # Check the appropriate enemy directory
            directory = os.path.join(ENEMY_SPRITES_PATH, enemy_type)
            if os.path.exists(directory):
                files = [f for f in os.listdir(directory) if f.endswith('.png')]
                if files:
                    return os.path.join(directory, random.choice(files))
            
            print(f"No textures found for enemy type: {enemy_type}")
            return None
        except Exception as e:
            print(f"Error getting enemy textures: {e}")
            return None
        
    def load_tile_textures(self):
        """Load textures for tiles used in this level"""
        # Initialize with placeholders
        self.tiles['wall'] = None
        self.tiles['destroyable_wall'] = None
        self.tiles['floor'] = None
        self.tiles['door'] = None
        self.tiles['exit'] = None
        self.tiles['exit_open'] = None
        
        try:
            # Wall texture
            wall_path = os.path.join(TILE_SPRITES_PATH, "walls", f"wall_{self.level_number}.png")
            if os.path.exists(wall_path):
                self.tiles['wall'] = self.asset_manager.load_image(wall_path, scale=(TILE_SIZE, TILE_SIZE))
                print(f"Loaded wall texture: {wall_path}")
            else:
                # Fallback to a random wall texture
                wall_dir = os.path.join(TILE_SPRITES_PATH, "walls")
                if os.path.exists(wall_dir):
                    wall_files = glob.glob(os.path.join(wall_dir, "*.png"))
                    if wall_files:
                        selected_wall = random.choice(wall_files)
                        self.tiles['wall'] = self.asset_manager.load_image(selected_wall, scale=(TILE_SIZE, TILE_SIZE))
                        print(f"Loaded random wall texture: {selected_wall}")
            
            # Destroyable wall texture (treasure chest)
            destroyable_texture = self.get_random_destroyable_wall_texture()
            if destroyable_texture:
                self.tiles['destroyable_wall'] = self.asset_manager.load_image(destroyable_texture, scale=(TILE_SIZE, TILE_SIZE))
                print(f"Loaded destroyable wall texture: {destroyable_texture}")
            
            # Floor texture
            floor_path = os.path.join(TILE_SPRITES_PATH, "floors", f"floor_{self.level_number}.png")
            if os.path.exists(floor_path):
                self.tiles['floor'] = self.asset_manager.load_image(floor_path, scale=(TILE_SIZE, TILE_SIZE))
                print(f"Loaded floor texture: {floor_path}")
            else:
                # Fallback to a random floor texture
                floor_dir = os.path.join(TILE_SPRITES_PATH, "floors")
                if os.path.exists(floor_dir):
                    floor_files = glob.glob(os.path.join(floor_dir, "*.png"))
                    if floor_files:
                        selected_floor = random.choice(floor_files)
                        self.tiles['floor'] = self.asset_manager.load_image(selected_floor, scale=(TILE_SIZE, TILE_SIZE))
                        print(f"Loaded random floor texture: {selected_floor}")
            
            # Door texture
            door_path = os.path.join(TILE_SPRITES_PATH, "doors", f"door_{self.level_number}.png")
            if os.path.exists(door_path):
                self.tiles['door'] = self.asset_manager.load_image(door_path, scale=(TILE_SIZE, TILE_SIZE))
                print(f"Loaded door texture: {door_path}")
            else:
                # Fallback to a random door texture
                door_dir = os.path.join(TILE_SPRITES_PATH, "doors")
                if os.path.exists(door_dir):
                    door_files = glob.glob(os.path.join(door_dir, "*.png"))
                    if door_files:
                        selected_door = random.choice(door_files)
                        self.tiles['door'] = self.asset_manager.load_image(selected_door, scale=(TILE_SIZE, TILE_SIZE))
                        print(f"Loaded random door texture: {selected_door}")
            
            # Load textures for the exit door
            self.load_exit_door_textures()
            
            # Key texture
            key_path = os.path.join(ITEM_SPRITES_PATH, "key.png")
            if os.path.exists(key_path):
                self.tiles['key'] = self.asset_manager.load_image(key_path, scale=(TILE_SIZE, TILE_SIZE))
                print(f"Loaded key texture: {key_path}")
                
        except Exception as e:
            print(f"Error loading tile textures: {e}")
    
    def load_exit_door_textures(self):
        """Load textures for the exit door"""
        try:
            # Closed exit door
            exit_path = os.path.join(TILE_SPRITES_PATH, "doors", "exit_closed.png")
            if os.path.exists(exit_path):
                self.tiles['exit'] = self.asset_manager.load_image(exit_path, scale=(TILE_SIZE, TILE_SIZE))
                print(f"Loaded exit door texture: {exit_path}")
            
            # Open exit door
            exit_open_path = os.path.join(TILE_SPRITES_PATH, "doors", "exit_open.png")
            if os.path.exists(exit_open_path):
                self.tiles['exit_open'] = self.asset_manager.load_image(exit_open_path, scale=(TILE_SIZE, TILE_SIZE))
                print(f"Loaded open exit door texture: {exit_open_path}")
                
                # Create a glowing version of the exit door
                try:
                    glow_size = TILE_SIZE * 2
                    glow_surface = pygame.Surface((glow_size, glow_size), pygame.SRCALPHA)
                    
                    # Draw a radial gradient for the glow
                    center = glow_size // 2
                    for radius in range(center, 0, -1):
                        # Decrease alpha as radius increases
                        alpha = int(255 * (1 - radius / center))
                        color = (255, 255, 0, alpha)  # Yellow glow
                        pygame.draw.circle(glow_surface, color, (center, center), radius)
                    
                    self.tiles['exit_open_glow'] = glow_surface
                    print("Created glowing effect for exit door")
                except Exception as e:
                    print(f"Error creating exit door glow: {e}")
                    
        except Exception as e:
            print(f"Error loading exit door textures: {e}")
    
    def generate_level(self):
        """Generate a multi-room dungeon level"""
        # Determine number of rooms based on level
        base_rooms = 5  # Minimum rooms per level
        additional_rooms = self.level_number * 2  # More rooms for higher levels
        max_rooms = base_rooms + additional_rooms
        
        # Always have at least 5 rooms
        max_rooms = max(5, max_rooms)
        
        # Start with a central room
        start_x, start_y = 0, 0
        self.rooms[(start_x, start_y)] = Room(start_x, start_y, self.level_number, 'start')
        self.start_room_coords = (start_x, start_y)
        self.current_room_coords = (start_x, start_y)
        
        # Keep track of rooms we've generated and their positions
        room_positions = [(start_x, start_y)]
        
        # Generate a branching dungeon, ensuring all rooms are connected
        rooms_created = 1
        
        # Determine boss and treasure room counts
        boss_room_count = min(1, self.level_number // 3 + 1)  # 1 boss room, more in higher levels
        treasure_room_count = min(2, self.level_number // 2 + 1)  # More treasure rooms in higher levels
        
        # Create normal rooms first by branching from existing rooms
        while rooms_created < max_rooms - (boss_room_count + treasure_room_count):
            # Pick a random existing room to branch from
            parent_pos = random.choice(room_positions)
            parent_x, parent_y = parent_pos
            
            # Try to add a room in a random direction
            directions = [(0, -1), (1, 0), (0, 1), (-1, 0)]  # North, East, South, West
            random.shuffle(directions)
            
            for dx, dy in directions:
                new_x, new_y = parent_x + dx, parent_y + dy
                
                # If this position is free (no room yet)
                if (new_x, new_y) not in self.rooms:
                    # Add a new room here
                    self.rooms[(new_x, new_y)] = Room(new_x, new_y, self.level_number, 'normal')
                    room_positions.append((new_x, new_y))
                    
                    # Connect rooms with doors
                    if dx == 0 and dy == -1:  # North
                        self.rooms[(parent_x, parent_y)].doors['north'] = True
                        self.rooms[(new_x, new_y)].doors['south'] = True
                    elif dx == 1 and dy == 0:  # East
                        self.rooms[(parent_x, parent_y)].doors['east'] = True
                        self.rooms[(new_x, new_y)].doors['west'] = True
                    elif dx == 0 and dy == 1:  # South
                        self.rooms[(parent_x, parent_y)].doors['south'] = True
                        self.rooms[(new_x, new_y)].doors['north'] = True
                    elif dx == -1 and dy == 0:  # West
                        self.rooms[(parent_x, parent_y)].doors['west'] = True
                        self.rooms[(new_x, new_y)].doors['east'] = True
                    
                    rooms_created += 1
                    break
        
        # Add boss room(s)
        for _ in range(boss_room_count):
            if rooms_created >= max_rooms:
                break
                
            # Add boss room connected to a random normal room
            # Find normal rooms that have at least one open direction
            potential_parents = []
            for pos, room in self.rooms.items():
                if room.room_type == 'normal':
                    # Count open directions (no door)
                    open_doors = sum(1 for door_open in room.doors.values() if not door_open)
                    if open_doors > 0:
                        potential_parents.append(pos)
            
            if not potential_parents:
                print("No suitable parent room for boss room found")
                break
                
            parent_pos = random.choice(potential_parents)
            parent_x, parent_y = parent_pos
            
            # Try to add a room in a random open direction
            directions = [(0, -1, 'north'), (1, 0, 'east'), (0, 1, 'south'), (-1, 0, 'west')]
            random.shuffle(directions)
            
            for dx, dy, dir_name in directions:
                new_x, new_y = parent_x + dx, parent_y + dy
                
                # If this position is free and the door is not already open
                if (new_x, new_y) not in self.rooms and not self.rooms[parent_pos].doors[dir_name]:
                    # Add a boss room here
                    self.rooms[(new_x, new_y)] = Room(new_x, new_y, self.level_number, 'boss')
                    self.rooms[(new_x, new_y)].spawn_boss(self)  # Spawn a boss in this room
                    
                    # Connect rooms with doors
                    self.rooms[parent_pos].doors[dir_name] = True
                    opposite_dir = {
                        'north': 'south',
                        'east': 'west',
                        'south': 'north',
                        'west': 'east'
                    }[dir_name]
                    self.rooms[(new_x, new_y)].doors[opposite_dir] = True
                    
                    rooms_created += 1
                    break
        
        # Add treasure room(s)
        for _ in range(treasure_room_count):
            if rooms_created >= max_rooms:
                break
                
            # Add treasure room connected to a random room
            potential_parents = []
            for pos, room in self.rooms.items():
                # Count open directions (no door)
                open_doors = sum(1 for door_open in room.doors.values() if not door_open)
                if open_doors > 0:
                    potential_parents.append(pos)
            
            if not potential_parents:
                print("No suitable parent room for treasure room found")
                break
                
            parent_pos = random.choice(potential_parents)
            parent_x, parent_y = parent_pos
            
            # Try to add a room in a random open direction
            directions = [(0, -1, 'north'), (1, 0, 'east'), (0, 1, 'south'), (-1, 0, 'west')]
            random.shuffle(directions)
            
            for dx, dy, dir_name in directions:
                new_x, new_y = parent_x + dx, parent_y + dy
                
                # If this position is free and the door is not already open
                if (new_x, new_y) not in self.rooms and not self.rooms[parent_pos].doors[dir_name]:
                    # Add a treasure room here
                    self.rooms[(new_x, new_y)] = Room(new_x, new_y, self.level_number, 'treasure')
                    
                    # Connect rooms with doors
                    self.rooms[parent_pos].doors[dir_name] = True
                    opposite_dir = {
                        'north': 'south',
                        'east': 'west',
                        'south': 'north',
                        'west': 'east'
                    }[dir_name]
                    self.rooms[(new_x, new_y)].doors[opposite_dir] = True
                    
                    rooms_created += 1
                    break
        
        # Add the exit to the furthest room from start
        # First calculate distances from start
        distances = {}
        for pos in self.rooms.keys():
            dx, dy = pos[0] - start_x, pos[1] - start_y
            distances[pos] = abs(dx) + abs(dy)  # Manhattan distance
        
        # Sort rooms by distance, furthest first
        sorted_rooms = sorted(distances.items(), key=lambda x: x[1], reverse=True)
        
        # Set the exit in the furthest room that's not a boss room
        for pos, _ in sorted_rooms:
            if self.rooms[pos].room_type != 'boss':
                self.exit_room_coords = pos
                self.add_exit_to_room(pos)
                break
        
        # Spawn enemies in normal rooms
        for pos, room in self.rooms.items():
            if room.room_type == 'normal':
                # Determine number of enemies based on level and distance from start
                base_enemies = 2 + distances[pos] // 2  # More enemies further from start
                level_scaling = self.level_number // 2  # More enemies in higher levels
                
                num_enemies = min(base_enemies + level_scaling, 8)  # Cap at 8 enemies per room
                room.spawn_enemies(num_enemies, self)
        
        # Add fire sword pickup to level 2 boss room
        if self.level_number == 2:
            boss_rooms = [pos for pos, room in self.rooms.items() if room.room_type == 'boss']
            if boss_rooms:
                boss_room_pos = boss_rooms[0]
                boss_room = self.rooms[boss_room_pos]
                
                # Place the fire sword pickup at a valid position in the boss room
                center_x = (boss_room.width // 2) * TILE_SIZE + TILE_SIZE // 2
                center_y = (boss_room.height // 2) * TILE_SIZE + TILE_SIZE // 2
                
                boss_room.fire_sword_pickup = FireSwordPickup(center_x, center_y)
                print(f"Added fire sword pickup to boss room at level {self.level_number}")
    
    def add_exit_to_room(self, room_pos):
        """Add an exit door to the specified room"""
        room = self.rooms[room_pos]
        room.has_exit = True
        
        # Place exit at a wall position, preferably not near a door
        center_x, center_y = room.width // 2, room.height // 2
        
        # Try to place along a wall
        wall_positions = []
        
        # Check all wall positions around the room perimeter
        for y in range(1, room.height - 1):
            for x in range(1, room.width - 1):
                # Only consider positions that are currently walls and not near doors
                if room.tiles[y][x] == 1 and not room.near_door(x, y):
                    # Check if it's along the outer wall (not including corners)
                    is_on_perimeter = (
                        x == 1 or x == room.width - 2 or
                        y == 1 or y == room.height - 2
                    )
                    if is_on_perimeter:
                        wall_positions.append((x, y))
        
        if wall_positions:
            # Choose a random wall position
            exit_pos = random.choice(wall_positions)
            room.exit_position = exit_pos
            
            # Convert wall to exit door
            room.tiles[exit_pos[1]][exit_pos[0]] = EXIT_DOOR_TILE
            
            print(f"Added exit door at position {exit_pos} in room {room_pos}")
        else:
            # Fallback - place exit at center of the room
            exit_pos = (center_x, center_y)
            room.exit_position = exit_pos
            
            # Make sure the position is a floor tile
            room.tiles[exit_pos[1]][exit_pos[0]] = EXIT_DOOR_TILE
            
            print(f"Added exit door at center position {exit_pos} in room {room_pos}")
    
    def get_valid_player_start_position(self):
        """Get a valid starting position for the player in the first room"""
        start_room = self.rooms[self.start_room_coords]
        return start_room.get_valid_player_position()
    
    def get_player_position_after_door(self, door_direction):
        """Get the player's new position after going through a door"""
        current_room = self.rooms[self.current_room_coords]
        new_coords = None
        
        # Calculate new room coordinates based on door direction
        if door_direction == 'north':
            new_coords = (self.current_room_coords[0], self.current_room_coords[1] - 1)
        elif door_direction == 'east':
            new_coords = (self.current_room_coords[0] + 1, self.current_room_coords[1])
        elif door_direction == 'south':
            new_coords = (self.current_room_coords[0], self.current_room_coords[1] + 1)
        elif door_direction == 'west':
            new_coords = (self.current_room_coords[0] - 1, self.current_room_coords[1])
        
        if new_coords and new_coords in self.rooms:
            new_room = self.rooms[new_coords]
            
            # Position the player just inside the door on the opposite side
            if door_direction == 'north':
                # Player went north, put them at the south entrance of the new room
                x = (new_room.width // 2) * TILE_SIZE + TILE_SIZE // 2
                y = (new_room.height - 2) * TILE_SIZE + TILE_SIZE // 2
            elif door_direction == 'east':
                # Player went east, put them at the west entrance of the new room
                x = 2 * TILE_SIZE + TILE_SIZE // 2
                y = (new_room.height // 2) * TILE_SIZE + TILE_SIZE // 2
            elif door_direction == 'south':
                # Player went south, put them at the north entrance of the new room
                x = (new_room.width // 2) * TILE_SIZE + TILE_SIZE // 2
                y = 2 * TILE_SIZE + TILE_SIZE // 2
            elif door_direction == 'west':
                # Player went west, put them at the east entrance of the new room
                x = (new_room.width - 2) * TILE_SIZE + TILE_SIZE // 2
                y = (new_room.height // 2) * TILE_SIZE + TILE_SIZE // 2
            
            # Check if this position is valid (not a wall)
            tile_x, tile_y = x // TILE_SIZE, y // TILE_SIZE
            
            # If the position is a wall, search for a nearby floor tile
            if new_room.tiles[tile_y][tile_x] == 1:
                # Search around doorway for floor tiles
                for offset_y in range(-2, 3):
                    for offset_x in range(-2, 3):
                        check_x = tile_x + offset_x
                        check_y = tile_y + offset_y
                        
                        if (0 <= check_y < new_room.height and 
                            0 <= check_x < new_room.width and
                            new_room.tiles[check_y][check_x] == 0):
                            # Found a valid floor tile
                            return (check_x * TILE_SIZE + TILE_SIZE // 2, 
                                   check_y * TILE_SIZE + TILE_SIZE // 2,
                                   new_coords)
            
            # Return the door position and the new room coordinates
            return x, y, new_coords
        
        return None
    
    def check_door_transition(self, player_rect):
        """Check if player is touching a door to transition to another room,
           returns new (x, y) position and room coords if so"""
        current_room = self.rooms[self.current_room_coords]
        
        # Check if player is touching a door
        door_direction = current_room.check_door_collision(player_rect)
        if door_direction:
            print(f"Player touched {door_direction} door")
            # Calculate new position
            new_position = self.get_player_position_after_door(door_direction)
            if new_position:
                # Return the direction and new position to match what main.py expects
                return door_direction, (new_position[0], new_position[1], new_position[2])
            
        return None, None  # Return None, None to match expected return values
    
    def check_key_pickup(self, player_rect):
        """Check if player has picked up a key"""
        current_room = self.rooms[self.current_room_coords]
        
        # Check if room has a dropped key that hasn't been picked up
        if current_room.key_dropped and not current_room.key_picked_up:
            # Create a collision rect for the key
            key_rect = pygame.Rect(
                current_room.key_position[0] - TILE_SIZE//4,
                current_room.key_position[1] - TILE_SIZE//4,
                TILE_SIZE//2, TILE_SIZE//2
            )
            
            # Check if player collides with key
            if player_rect.colliderect(key_rect):
                print("Player picked up a key!")
                current_room.key_picked_up = True
                self.has_key = True
                return True
                
        return False
    
    def check_exit_use(self, player_rect):
        """Check if player is using the exit door"""
        current_room = self.rooms[self.current_room_coords]
        
        if current_room.has_exit and current_room.exit_position:
            exit_x, exit_y = current_room.exit_position
            exit_rect = pygame.Rect(
                exit_x * TILE_SIZE,
                exit_y * TILE_SIZE,
                TILE_SIZE, TILE_SIZE
            )
            
            if player_rect.colliderect(exit_rect):
                # If player has the key, show exit confirmation
                if self.has_key and not self.show_exit_confirmation:
                    print("Player using exit with key! Showing confirmation.")
                    self.show_exit_confirmation = True
                    return True
                # If player doesn't have the key, give feedback
                elif not self.has_key and not self.show_exit_confirmation:
                    print("Player attempted to use exit without key!")
                    # No need to show confirmation, just give feedback
                    return False
                    
        return False
        
    def confirm_exit(self):
        """Confirm the player's exit to the next level"""
        self.show_exit_confirmation = False
        self.completed = True  # Mark the level as completed
        print("Exit confirmed - going to next level!")
        return True
        
    def cancel_exit(self):
        """Cancel the exit confirmation"""
        self.show_exit_confirmation = False
        print("Exit cancelled")
    
    def update(self, player):
        """Update the current room and check for key pickups and exit usage"""
        try:
            current_room = self.rooms[self.current_room_coords]
            current_room.update(player)
            
            # Check for key pickup
            self.check_key_pickup(player.rect)
            
            # Check for door transitions
            transition = self.check_door_transition(player.rect)
            if transition:
                # Return the transition info - new position and room
                return transition
                
            # Check for exit door usage
            self.check_exit_use(player.rect)
            
            return None
        except Exception as e:
            print(f"Error in Level.update: {e}")
            return None
    
    def check_collision(self, rect):
        """Check for collisions with walls in the current room"""
        try:
            current_room = self.rooms[self.current_room_coords]
            return current_room.check_collision(rect)
        except Exception as e:
            print(f"Error in check_collision: {e}")
            return False
    
    def try_destroy_wall(self, x, y):
        """Try to destroy a wall at the specified coordinates"""
        try:
            print(f"Level: Trying to destroy wall at {x}, {y}")
            current_room = self.rooms[self.current_room_coords]
            
            # Convert pixel coordinates to tile coordinates
            tile_x = x // TILE_SIZE
            tile_y = y // TILE_SIZE
            
            print(f"Level: Converted to tile coordinates: {tile_x}, {tile_y}")
            return current_room.try_destroy_wall(tile_x, tile_y)
        except Exception as e:
            print(f"Error in try_destroy_wall: {e}")
            return False
    
    def check_health_pickup(self, player_rect):
        """Check if player is picking up health"""
        try:
            current_room = self.rooms[self.current_room_coords]
            return current_room.try_pickup_health(player_rect)
        except Exception as e:
            print(f"Error in check_health_pickup: {e}")
            return 0

    def check_arrow_pickup(self, player_rect):
        """Check if player is picking up arrows"""
        try:
            current_room = self.rooms[self.current_room_coords]
            return current_room.try_pickup_arrows(player_rect)
        except Exception as e:
            print(f"Error in check_arrow_pickup: {e}")
            return 0
            
    def check_fire_sword_pickup(self, player_rect):
        """Check if player is picking up the fire sword"""
        try:
            current_room = self.rooms[self.current_room_coords]
            return current_room.try_pickup_fire_sword(player_rect)
        except Exception as e:
            print(f"Error in check_fire_sword_pickup: {e}")
            return False
            
    def check_fire_sword_chest_destruction(self, attack_rect):
        """Check if player's attack is destroying the fire sword chest"""
        try:
            current_room = self.rooms[self.current_room_coords]
            return current_room.try_destroy_fire_sword_chest(attack_rect)
        except Exception as e:
            print(f"Error in check_fire_sword_chest_destruction: {e}")
            return False
            
    def draw(self, surface):
        """Draw only the current room"""
        try:
            current_room = self.rooms[self.current_room_coords]
            current_room.draw(surface, self.tiles, self)
        except Exception as e:
            print(f"Error in Level.draw: {e}")